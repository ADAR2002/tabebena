import { Injectable, NotFoundException } from "@nestjs/common";
import { BloodType as PrismaBloodType } from "@prisma/client";
import { PrismaService } from "../prisma/prisma.service";
import { CreatePatientDto } from "./dto/create-patient.dto";
import { UpdatePatientDto } from "./dto/update-patient.dto";
import { Patient } from "./entities/patient.entity";
import { PaginatedResult } from "../common/interfaces/paginated-result.interface";

@Injectable()
export class PatientsService {
  constructor(private prisma: PrismaService) {}

  private mapBloodTypeToPrisma(bloodType?: string): PrismaBloodType | null | undefined {
    if (!bloodType) return undefined;

    const map: Record<string, PrismaBloodType> = {
      "A+": PrismaBloodType.A_PLUS,
      "A-": PrismaBloodType.A_MINUS,
      "B+": PrismaBloodType.B_PLUS,
      "B-": PrismaBloodType.B_MINUS,
      "AB+": PrismaBloodType.AB_PLUS,
      "AB-": PrismaBloodType.AB_MINUS,
      "O+": PrismaBloodType.O_PLUS,
      "O-": PrismaBloodType.O_MINUS,
    };

    return map[bloodType] ?? null;
  }

  private mapPrismaBloodTypeToDisplay(
    bloodType?: PrismaBloodType | null
  ): string | null {
    if (!bloodType) return null;
    const map: Record<PrismaBloodType, string> = {
      [PrismaBloodType.A_PLUS]: "A+",
      [PrismaBloodType.A_MINUS]: "A-",
      [PrismaBloodType.B_PLUS]: "B+",
      [PrismaBloodType.B_MINUS]: "B-",
      [PrismaBloodType.AB_PLUS]: "AB+",
      [PrismaBloodType.AB_MINUS]: "AB-",
      [PrismaBloodType.O_PLUS]: "O+",
      [PrismaBloodType.O_MINUS]: "O-",
    };
    return map[bloodType];
  }

  private async decoratePatient(
    patient: any,
    doctorId: string
  ): Promise<Patient> {
    const [nextAppointment, lastVisit] = await Promise.all([
      this.prisma.appointment.findFirst({
        where: {
          patientId: patient.id,
          doctorId: doctorId,
          dateAndTime: { gt: new Date() },
        },
        orderBy: { dateAndTime: "asc" },
        select: { dateAndTime: true },
      }),
      this.prisma.visit.findFirst({
        where: { patientId: patient.id },
        orderBy: { visitDate: "desc" },
        select: { visitDate: true },
      }),
    ]);

    return {
      ...patient,
      bloodType: this.mapPrismaBloodTypeToDisplay(patient.bloodType),
      nextAppointment: nextAppointment?.dateAndTime ?? null,
      lastSession: lastVisit?.visitDate ?? null,
    } as Patient;
  }

  async create(
    doctorId: string,
    createPatientDto: CreatePatientDto
  ): Promise<Patient> {
    const { bloodType, ...rest } = createPatientDto;

    const created = await this.prisma.patient.create({
      data: {
        ...rest,
        bloodType: this.mapBloodTypeToPrisma(bloodType),
        dateOfBirth: new Date(createPatientDto.dateOfBirth),
        doctorUserId: doctorId,
        
      },
    });
    return this.decoratePatient(created, doctorId);
  }

  async findAll(
    doctorId: string,
    page: number = 1,
    limit: number = 10,
    name?: string,
    phone?: string
  ): Promise<PaginatedResult<Patient>> {
    const skip = (page - 1) * limit;

    const orConditions: any[] = [];
    if (name) orConditions.push({ fullName: { contains: name } });
    if (phone) orConditions.push({ phone: { contains: phone } });

    const where: any = {
      doctorUserId: doctorId,
      ...(orConditions.length ? { OR: orConditions } : {}),
    };

    const [data, total] = await Promise.all([
      this.prisma.patient.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: "desc" },
      }),
      this.prisma.patient.count({ where }),
    ]);

    const decorated = await Promise.all(
      data.map((p) => this.decoratePatient(p, doctorId))
    );

    const totalPages = Math.ceil(total / limit);

    return {
      data: decorated,
      meta: {
        total,
        page,
        limit,
        totalPages,
      },
    };
  }

  async findById(doctorId: string, id: string): Promise<Patient> {
    const patient = await this.prisma.patient.findFirst({
      where: {
        id,
        doctorUserId: doctorId,
      },
    });

    if (!patient) {
      throw new NotFoundException(`Patient with id ${id} not found`);
    }

    return this.decoratePatient(patient, doctorId);
  }

  async findOne(phone: string, doctorId: string): Promise<Patient> {
    const patient = await this.prisma.patient.findFirst({
      where: {
        phone: phone,
        doctorUserId: doctorId,
      },
    });

    if (!patient) {
      throw new NotFoundException(`Patient with phone ${phone} not found`);
    }

    return this.decoratePatient(patient, doctorId);
  }

  async update(
    phone: string,
    doctorId: string,
    updatePatientDto: UpdatePatientDto
  ): Promise<Patient> {
    const patient = await this.findOne(phone, doctorId);

    const { bloodType, ...rest } = updatePatientDto;

    const updated = await this.prisma.patient.update({
      where: { id: patient.id, doctorUserId: doctorId },
      data: {
        ...rest,
        ...(bloodType !== undefined && {
          bloodType: this.mapBloodTypeToPrisma(bloodType),
        }),
      },
    });
    return this.decoratePatient(updated, doctorId);
  }

  async remove(phone: string, doctorId: string): Promise<void> {
    
    const patient = await this.findOne(phone, doctorId);

    await this.prisma.patient.delete({
      where: { id: patient.id, doctorUserId: doctorId },
    });
  }

  // search logic consolidated into findAll

  async updateById(
    id: string,
    doctorId: string,
    updatePatientDto: UpdatePatientDto
  ): Promise<Patient> {
    const existing = await this.prisma.patient.findFirst({
      where: { id, doctorUserId: doctorId },
    });
    if (!existing) {
      throw new NotFoundException(`Patient with id ${id} not found`);
    }

    const { bloodType, ...rest } = updatePatientDto;
    const updated = await this.prisma.patient.update({
      where: { id },
      data: {
        ...rest,
        ...(bloodType !== undefined && {
          bloodType: this.mapBloodTypeToPrisma(bloodType),
        }),
      },
    });
    return this.decoratePatient(updated, doctorId);
  }

  async removeById(id: string, doctorId: string): Promise<void> {
    const existing = await this.prisma.patient.findFirst({
      where: { id, doctorUserId: doctorId },
    });
    if (!existing) {
      throw new NotFoundException(`Patient with id ${id} not found`);
    }

    await this.prisma.patient.delete({ where: { id } });
  }
}
